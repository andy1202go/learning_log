# LeetCode

[toc]

## 逐题解决

题目：

> d

思路：

- 

代码：

```java

```

结果和分析：

- 结果：性能等
- 分析：

进阶：



```java

```

标签：

### 1 两数之和

题目：

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,2,4], target = 6
> 输出：[1,2]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [3,3], target = 6
> 输出：[0,1]
> ```
>
>  
>
> **提示：**
>
> - `2 <= nums.length <= 104`
> - `-109 <= nums[i] <= 109`
> - `-109 <= target <= 109`
> - **只会存在一个有效答案**
>
> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？
>
> Related Topics
>
> 数组
>
> 哈希表

思路：

- 两次遍历看下就行
- 但是性能比较差

代码：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int result[] = new int[2];
        for (int i = 0; i < nums.length - 1; i++) {
            int left = target - nums[i];
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == left) {
                    result[0] = i;
                    result[1] = j;
                }
            }
        }
        return result;
    }
}
```

结果和分析：

- 结果：执行耗时:34 ms,击败了43.76% 的Java用户
  			内存消耗:38.5 MB,击败了64.39% 的Java用户
- 分析：O(n<sup>2</sup>)导致

进阶：

- 时间复杂度目标是O(n)
- 增加空间消耗来实现遍历一遍，找到结果
- 存储位置信息即可
- 执行耗时:2 ms,击败了86.22% 的Java用户
  内存消耗:38.3 MB,击败了90.90% 的Java用户

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int result[] = new int[2];
        for (int i = 0; i < nums.length; i++){
            int num = target - nums[i];
            if(map.containsKey(num)){
                result[0] = map.get(num);
                result[1] = i;
                return result;
            }
            map.put(nums[i], i);
        }
        return result;
    }
}
```

总结：

- 利用hash的key-value对的存储信息的能力
- 空间换时间

标签：求和，哈希

### 7 整数反转

题目:

> 给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。
>
> 如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。
>
> **假设环境不允许存储 64 位整数（有符号或无符号）。**
>
>  
>
> **示例 1：**
>
> ```
> 输入：x = 123
> 输出：321
> ```
>
> **示例 2：**
>
> ```
> 输入：x = -123
> 输出：-321
> ```
>
> **示例 3：**
>
> ```
> 输入：x = 120
> 输出：21
> ```
>
> **示例 4：**
>
> ```
> 输入：x = 0
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `-231 <= x <= 231 - 1`
>
> Related Topics
>
> 数学

思路：

- 转成String，利用String的reverse能力来做
- String避免了溢出，但String的compareTo要注意细节
- 负数细节注意

代码：

```java
class Solution {
    public int reverse(int x) {
        if (x == 0 || x == Integer.MIN_VALUE) {
            return 0;
        }
        boolean neg = x < 0 ? true : false;
        String origin = String.valueOf(x);
        if (neg) {
            origin = origin.substring(1);
        }
        String rev = new StringBuilder(origin).reverse().toString();
        if (rev.startsWith("0")) {
            rev = rev.substring(1);
        }
        String max = String.valueOf(Integer.MAX_VALUE);
        if (rev.length()>=max.length() && rev.compareTo(max) >= 0) {
            return 0;
        }
        if (neg) {
            rev = "-" + rev;
        }
        return Integer.valueOf(rev);
    }
}
```

结果和分析：

- 结果：执行耗时:3 ms,击败了13.84% 的Java用户
  			内存消耗:35.7 MB,击败了16.59% 的Java用户
- 分析：
  - 用StringBuilder确实方便，但是性能真的堪忧；
  - 代码十分不优雅...

进阶：

- 发现大多单刀直入，从数学角度考虑这个问题

- 取每一位然后反转——取模

- 使用String的反转，问题在于使用库函数较多，字符串的反转效率较低（？）

- >#### 解题思路：
  >
  >首先我们想一下，怎么去反转`一个整数`？
  >用栈？
  >或者把整数变成字符串，再去反转这个字符串？
  >这两种方式是可以，但并不好。实际上我们只要能拿到这个整数的 **末尾数字** 就可以了。
  >以`12345`为例，先拿到`5`，再拿到`4`，之后是`3`，`2`，`1`，我们按这样的顺序就可以反向拼接处一个数字了，也就能达到 **反转** 的效果。
  >怎么拿末尾数字呢？好办，用取模运算就可以了
  >
  >![1jpg](https://pic.leetcode-cn.com/be35cb60bec9a9ae794abad671e6618abb5664780bc7ee30ca93ca423884a666-1.jpg)
  >
  >1、将`12345 % 10` 得到`5`，之后将`12345 / 10`
  >2、将`1234 % 10` 得到`4`，再将`1234 / 10`
  >3、将`123 % 10` 得到`3`，再将`123 / 10`
  >4、将`12 % 10` 得到`2`，再将`12 / 10`
  >5、将`1 % 10` 得到`1`，再将`1 / 10`
  >
  >这么看起来，一个循环就搞定了，循环的判断条件是`x>0`
  >但这样不对，因为忽略了 **负数**
  >循环的判断条件应该是`while(x!=0)`，无论正数还是负数，按照上面不断的`/10`这样的操作，最后都会变成`0`，所以判断终止条件就是`!=0`
  >有了取模和除法操作，对于像`12300`这样的数字，也可以完美的解决掉了。
  >
  >看起来这道题就这么解决了，但请注意，题目上还有这么一句
  >
  >> 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 `[−2^31, 2^31 − 1]`。
  >
  >也就是说我们不能用`long`存储最终结果，而且有些数字可能是合法范围内的数字，但是**反转**过来就超过范围了。
  >假设有`1147483649`这个数字，它是小于最大的32位整数`2147483647`的，但是将这个数字反转过来后就变成了`9463847411`，这就比最大的32位整数还要大了，这样的数字是没法存到`int`里面的，所以肯定要返回`0`(溢出了)。 甚至，我们还需要提前判断
  >
  >![2jpg](https://pic.leetcode-cn.com/42c736510f4914af169907d61b22d1a39bd5a16bbd7eca0466d90350e2763164-2.jpg)
  >
  >上图中，绿色的是最大32位整数
  >第二排数字中，橘子的是`5`，它是大于上面同位置的`4`，这就意味着`5`后跟任何数字，都会比最大32为整数都大。
  >所以，我们到【最大数的1/10】时，就要开始判断了
  >如果某个数字**大于** `214748364`那后面就不用再判断了，肯定溢出了。
  >如果某个数字**等于** `214748364`呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的**末尾数字**比较，如果这个数字比`7`还大，说明溢出了。
  >
  >对于负数也是一样的
  >
  >![3jpg](https://pic.leetcode-cn.com/525aa75c19702e57b780c91a7ebb990359b14e96acc09b6327d9e1f0a5b3a16a-3.jpg)
  >
  >上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断
  >如果某个数字**小于** `-214748364`说明溢出了
  >如果某个数字**等于** `-214748364`，还需要跟最小数的末尾比较，即看它是否小于`8`

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //每次取末尾数字
            int tmp = x%10;
            //判断是否 大于 最大32位整数
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
}	
```

标签：数学



























## 思路总结

#### 1 hash的key-value对的存储信息的能力

#### 2 空间换时间

#### 3 通过取模来取每一位数字

## 参考文献

1 

## TODO List

| 时间               | 内容                                  |      |
| ------------------ | ------------------------------------- | ---- |
| 字符串处理性能如何 | 从StringBuilder的reverse()聊起，第7题 |      |
|                    |                                       |      |
|                    |                                       |      |



## 总结

| 时间 | 内容 |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



