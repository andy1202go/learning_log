# 38讲

[toc]

尝试掌握基础原理，从原理推导出各种技术实现。

> 太阳底下没有新鲜事，绝大多数新技术其实都脱胎于一些既有的技术体系。
>
> 如果你能建立起这套技术思维体系，掌握这套技术体系背后的原理，那么当你接触一个新技术的时候，就可以快速把握住这个新技术的本质特征和思路方法，然后用你的技术思维体系快速推导出这个新技术是如何实现的。这个时候你其实不需要去学习这个新技术了，而是去验证这个新技术，你会去看它的文档和代码，去验证它是不是和你推导、猜测的实现方式一致，而不是去学习它怎么用了。那么，学习一个新技术就变成了一个简单、轻松、快速且充满乐趣的过程了。你不再惧怕学习新技术，而是开始抱怨：为什么技术革新得这么慢，太无聊了。你甚至可以开始自己创造新技术。
>
> 物理学有一个第一性原理， 指的是根据一些最基本的物理学常量，从头进行物理学的推导，进而得到整个物理学体系。
>
> 第一性原理就是让我们抓住事物最本质的特征原理，依据事物本身的规律，去推导、分析、演绎事物的各种变化规律，进而洞悉事物在各种具体场景下的表现形式，而不是追随事物的表面现象，生搬硬套各种所谓的规矩、经验和技巧，以至于在各种纷繁复杂的冲突和纠结中迷失了方向。
>
> 我们应该从软件技术的第一性原理出发，了解每个基础技术方向那些最关键的技术原理，明白这些原理是如何和我们日常开发工作发生关系的。
>
> 比如我们的程序是如何被操作系统调度执行的？为什么高并发的时候系统会崩溃，原理是什么？在编程时，什么场合下应该使用链表，什么场合下应该使用数组，为什么？当我们使用 Hash 表的时候，什么情况下它的性能会急剧降低，原理又是什么？我们用 Redis 这样的分布式缓存的时候，到底要解决什么问题？分布式缓存是如何工作的？还有哪些技术看起来和 Redis 毫不相干，其实工作原理是一样的？
>
> 如果我们能把这些基本问题都回答清楚了，那么这些问题背后的核心技术原理也都理解了，我们就开始建立起自己的技术思维体系了。当有新的问题和技术出现，你就可以思考，这是属于哪个技术领域的？它的核心原理和哪个技术方案本质是一样的？



## 软件的基础原理

> 软件的基础原理主要是**操作系统、数据结构、数据库原理**等等，我会从一个常见的问题入手，直达这些基础技术最本质的原理，并覆盖这些基础技术的主要关键技术点，让你理解这些基础技术原理和你日常开发工作的关联关系，对这些基础技术有一个全新的认知。

### 01丨程序运行原理：程序是如何运行又是如何崩溃的？

#### 程序是如何运行起来的

- 程序员们编写的代码，经过编译后的可执行代码，都只是静态的，是为程序

- 把程序从磁盘加载到内存中（这个是执行代码的程序，调用系统接口实现的吗？），然后在操作系统的管理调度下交给CPU去执行；此时是进程；

- 进程包含

  - 可执行代码
  - 内存堆空间
  - 栈空间
  - 供操作系统使用的数据结构（？）

  ![img](\imgs\89c6e3bbc44cdc042e7a8bcddb3b4398.png)

- 操作系统把可执行代码加载到内存后，生成相应的数据结构和内存空间后，就从可执行代码的起始位置读取指令，交给CPU顺序执行；
- 堆是一块无序的内存空间，任何时候，进程需要申请内存，都是从堆中分一块出去；
- 分配的内存地址，记录在栈中；栈是严格的后进先出的结构
- 真正执行的函数，永远都在栈顶。栈帧是隔离的，所以不同函数可以定义相同的变量而不会发生混乱。（这个后面要找深入的了解下）

#### 计算机是如何同时处理数百个任务的

- 一句话总结是：CPU的分时共享技术；

- 进程的生命周期：运行、就绪、阻塞；

  > 运行：当一个进程在 CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于 CPU 的数目。
  >
  > 就绪：当一个进程获得了除 CPU 以外的一切所需资源，只要得到 CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。
  >
  > 阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待 I/O 完成，等待锁……）而暂时停止运行，这时即使把 CPU 分配给进程也无法运行，故称该进程处于阻塞状态。

- 进程间的CPU切换，性能开销较大；

- 线程可以理解为轻量级的进程，各种进程的概念都可以套用在线程上；

#### 系统为什么会变慢，为什么会崩溃

- 我们启动的服务，是以一个进程在运行；

- 进程内多线程来提供服务；

- 以 Java 的 web 开发为例，启动多线程，为每个用户请求分配一个处理线程的工作是在 web 容器中完成的，比如常用的 Tomcat 容器。

  ![img](\imgs\d40cc1e9a2a5ce3913670743f0543b9a.png)

- > Tomcat 启动多个线程，为每个用户请求分配一个线程，调用和请求 URL 路径相对应的 Servlet（或者 Controller）代码，完成用户请求处理。而 Tomcat 则在 JVM 虚拟机进程中，JVM 虚拟机则被操作系统当做一个独立进程管理。

- 不管你是否有意识，你开发的 web 程序都是被多线程执行的，web 开发天然就是多线程开发。

- 每个线程有自己的线程栈，所有的线程栈都是完全隔离的，也就是每个方法的参数和方法内的局部变量都是隔离的，一个线程无法访问到其他线程的栈内数据。

- > 多个线程访问共享资源的这段代码被称为临界区，解决线程安全问题的主要方法是使用锁，将临界区的代码加锁，只有获得锁的线程才能执行临界区代码

- 锁会引起线程阻塞，如果有很多线程同时在运行，那么就会出现线程排队等待锁的情况，线程无法并行执行，系统响应速度就会变慢。此外 I/O 操作也会引起阻塞，对数据库连接的获取也可能会引起阻塞。

- 被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，应用崩溃。

### 02丨数据结构原理：Hash表的时间复杂度为什么是O(1)？

要了解 Hash 表，需要先从数组说起。

#### 数组

- 数组是最常用的数据结构，两大要点：

1. 内存地址连续
2. 数据类型相同

- 正因为上述特点，所以可以给定下标，计算出位置，快速读取数据；

- 所以，数组在能力上的特点是：**随机快速读写**；O(1)

- 但如果想给定一个值，找其在数组中的位置啥的，不好意思，O(N)，遍历吧您哪！

#### 链表

- 特点：不连续的内存地址
- 能力：随机插入、删除比较容易；

#### Hash表

- hash：通过一定的规则，把任何值映射为一个数值，这个值就是hash

  > “Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。”

- 旨在解决数组无法很好处理的，通过一个值查到对应值的问题；

- 底层实际是数组，下标通过key的hash值得到；

- 常见的hash算法是取余法；

- 因为数组需要存储相同的数据类型，所以存的是内存地址；

- hash冲突时，相同数据通过链表保存；

- hash表的时间复杂度，在O(1)到O(N)之间摇摆；（极端情况）

#### 栈

- 数组和链表都是线性表，操作无限制；
- 加上操作限制，可以得到特定的数据结构；
- 栈，线性，后进先出；
- 因为是线性，所以可以基于数组或链表实现；

#### 队列

- 队列，线性，先进先出；

#### 树

- 非线性

### 03丨Java虚拟机原理：JVM为什么被称为机器（machine）？

通过JVM屏蔽操作系统的不同，实现了Java程序的一次编写，处处运行。实际上，可以认为JVM干了脏活累活，JVM对应各个操作系统是有不同版本的（比如下载JDK的时候，就是针对不同操作系统的）。

Java程序的一些重点，比如内存管理相关的报错（OOM，StackOverflow等）、线程安全问题等，都和JVM相关。

Java编程的第一性，是否可以考虑从JVM出发。

#### JVM 的组成构造

- JVM主要由三个部分组成：类加载器，运行时数据区，执行引擎；

  ![img](\imgs\62faabeecafe565cbd806022b2aa9c0a.jpg)

  ![img](\imgs\1846149-20200401105306155-3084373.png)

- 类加载器：把class文件加载到JVM中去，在内存中创建对象；不同的ClassLoader加载不同地方的类（jre的，自定义的，拓展的等）

- 运行时数据区（Runtime Data Area）：类似CPU的进程工作原理了。实际上JVM就是一个进程在跑，而程序的运行，是以线程为单位进行的。RDA又分为四个部分：方法区、堆、Java栈、程序计数寄存器（Method Area,Heap Area,Stack Area,PC Registers）；其中的方法区和堆是线程共享的，栈和计数器是线程独占的；

- 一个典型的 Java 程序运行过程是下面这样的

  > 通过 Java 命令启动 JVM，JVM 的类加载器根据 Java 命令的参数到指定的路径加载.class 类文件，类文件被加载到内存后，存放在专门的方法区。然后 JVM 创建一个主线程执行这个类文件的 main 方法，main 方法的输入参数和方法内定义的变量被压入 Java 栈。如果在方法内创建了一个对象实例，这个对象实例信息将会被存放到堆里，而对象实例的引用，也就是对象实例在堆中的地址信息则会被记录在栈里。堆中记录的对象实例信息主要是成员变量信息，因为类方法内的可执行代码存放在方法区，而方法内的局部变量存放在线程的栈里。
  >
  > 程序计数寄存器一开始存放的是 main 方法的第一行代码位置，JVM 的执行引擎根据这个位置去方法区的对应位置加载这行代码指令，将其解释为自身所在平台的 CPU 指令后交给 CPU 执行。如果在 main 方法里调用了其他方法，那么在进入其他方法的时候，会在 Java 栈中为这个方法创建一个新的栈帧，当线程在这个方法内执行的时候，方法内的局部变量都存放在这个栈帧里。当这个方法执行完毕退出的时候，就把这个栈帧从 Java 栈中出栈，这样当前栈帧，也就是堆栈的栈顶就又回到了 main 方法的栈帧，使用这个栈帧里的变量，继续执行 main 方法。这样，即使 main 方法和 f 方法都定义相同的变量，JVM 也不会弄错。这部分内容我们在第一篇已经讨论过，JVM 作为一个 machine，和操作系统的处理线程栈的的方法是一样的。

- 前面提到的JVM运行时数据区的共享和独占，引起了Java中令人头疼的线程安全问题。从栈的角度去理解线程安全的话，有以下几种情况：

  - 所有在方法内定义的基本类型变量，都会被每个运行这个方法的线程放入自己的栈中，线程的栈彼此隔离，所以这些变量一定是线程安全的
  - 如果在方法里创建了一个对象实例，这个对象实例如果没有被方法返回或者放入某些外部的对象容器中的话，也就是说这个对象的引用没有离开这个方法，虽然这个对象被放置在堆中，但是这个对象不会被其他线程访问到，也是线程安全的。
  - 像 Servlet 这样的类，在 Web 容器中创建以后，会被传递给每个访问 Web 应用的用户线程执行，这个类就不是线程安全的。但这并不意味着一定会引发线程安全问题。
  - 如果 Servlet 类里没有成员变量，即使多线程同时执行这个 Servlet 实例的方法，也不会造成成员变量冲突。这种对象被称作无状态对象，也就是说对象不记录状态，执行这个对象的任何方法都不会改变对象的状态，也就不会有线程安全问题了。
  - 虽然我们开发的 Web 应用都是多线程的应用，因为 Web 容器一定会创建多线程来执行我们的代码，但是我们开发中却可以很少考虑线程安全的问题。

- 执行引擎：大名鼎鼎的即时编译器JIT；https://www.cnblogs.com/codehaogg/p/13334713.html

#### JVM的垃圾回收

- JVM在操作系统的基础上更进一步，可以管理内存，也可以对内存标记做垃圾回收；

- 可达性分析：做标记，标记哪些对象被使用中。其实就两步：找到根节点，生成引用图；根节点一般为方法区静态变量、线程帧中的局部变量，从这些root找他们引用的对象，一步步分析。

- 回收算法演进：串行，并行，并发CMS，G1

  ![img](\imgs\492f81e739aba5664ebaf0e08b467134.png)

#### OOM和StackOverflow

- OutOfMemoryError，我们就知道是堆空间不足了，可能是 JVM 分配的内存空间不足以让程序正常运行，这时候我们需要通过调整 -Xmx 参数增加内存空间。也可能是程序存在内存泄漏，比如一些对象被放入 List 或者 Map 等容器对象中，虽然这些对象程序已经不再使用了，但是这些对象依然被容器对象引用，无法进行垃圾回收，导致内存溢出，这时候可以通过 jmap 命令查看堆中的对象情况，分析是否有内存泄漏。
- 如果遇到 StackOverflowError，我们就知道是线程栈空间不足，栈空间不足通常是因为方法调用的层次太多，导致栈帧太多。我们可以先通过栈异常信息观察是否存在错误的递归调用，因为每次递归都会使嵌套方法调用更深入一层。如果调用是正常的，可以尝试调整 -Xss 参数增加栈空间大小。
- 如果程序运行卡顿，部分请求响应延迟比较厉害，那么可以通过 jstat 命令查看垃圾回收器的运行状况，是否存在较长时间的 FullGC，然后调整垃圾回收器的相关参数，使垃圾回收对程序运行的影响尽可能小。

### 04丨网络编程原理：一个字符的互联网之旅

网络编程原理，主要是网络通信原理。

> 当我们进行网络通信编程的时候，通常需要关注两方面的内容，一方面是应用层的通信协议，主要是我们通信的数据如何编码，既能使网络传输过去的数据携带必要的信息，又使通信的两方都能正确识别这些数据，即通信双方应用程序需要约定一个数据编码协议。另一方面就是网络底层通信协议，即如何为网络上需要通信的两个节点建立连接完成数据传输

直接先上结论：

应用层的编码协议是HTTP协议，传输层是TCP，再加上IP做设备的互联网坐标，组成了TCP/IP协议栈，辅助各种其他协议，组成了互联网的约定。

#### DNS

一般不会去记录网站的ip地址，不直观，所以有了直观的通过域名翻译为ip地址的DNS域名解析服务。

所以，访问某个网址的时候，先访问DNS服务器，拿到ip地址后，再访问服务。

![img](\imgs\b66ab4aad74e047b671f59d9172c9f9a.png)

#### CDN

实际上，DNS解析出来的IP地址，可能不是真实服务的地址，可能是其CDN的IP地址。

CDN是内容分发网络，是运营服务商的机房中部署的缓存服务器，缓存占带宽的静态资源。

> CDN 是内容分发网络 Content Delivery Network 的缩写。我们能够用手机或者电脑上网，是因为运营服务商为我们提供了互联网接入服务，将我们的手机和电脑连接到互联网上。App 请求的数据最先到达的是运营服务商的机房，然后运营商通过自己建设的骨干网络和交换节点，将我们请求数据的目的地址发往互联网的任何地方。

![img](\imgs\2da7c834bfadb8aee3325cea78fbd7a4.png)

#### HTTP

请求的格式，都是遵循HTTP的。

#### TCP

> 应用程序使用操作系统的 socket 接口进行网络编程，socket 里封装了 TCP 协议。应用程序通过 socket 接口使用 TCP 协议完成网络编程，socket 或者 TCP 在应用程序看就是一个底层通信协议，事实上，TCP 仅仅是一个传输层协议，在传输层协议之下，还有网络层协议，网络层协议之下还有数据链路层协议，数据链路层协议之下还有物理层协议。

关于socket，可以认为是封装了一套接口，把TCP协议封装成了方便使用的接口：https://blog.csdn.net/weixin_42425141/article/details/80770419

> 传输层协议 TCP 和网络层协议 IP 共同构成 TCP/IP 协议栈，成为互联网应用开发最主要的通信协议。OSI 开放系统互联模型将网络协议定义了 7 层，TCP/IP 协议栈将 OSI 顶部三层协议应用层、表示层、会话层合并为一个应用层，HTTP 协议就是 TCP/IP 协议栈中的应用层协议。
>
> ![img](\imgs\ab0f73a9e8aef340dffa7fd64f299d9a.png)

应用层的典型就是HTTP，传输层是TCP，网络层是IP，链路层是MAC，物理层是各种硬件规范。

> 如果我们以 POST 方法提交一个搜索请求给淘宝服务器，那么最终在数据链路层构建出来的数据帧大概是这个样子，这里假设 IP 数据包的大小没有超过链路层的最大传输单元。
>
> ![img](\imgs\2ef260e20f190fed1d03febdea09378d.png)

#### LB（负载均衡）

请求到服务的时候，也不是直接访问的机器，多半是负载均衡服务器。

关于负载均衡，可以关注这篇：[就是要你懂负载均衡--lvs和转发模式](https://plantegg.github.io/2019/06/20/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1--lvs%E5%92%8C%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/)

几种类型，DR，NAT，IP TUN，关注指标是部署灵活性、负载均衡的性能。

DR下，请求图变成了

![img](\imgs\e0cbd3c93b67ed042c786862ede00f46.png)

### 05丨文件系统原理：如何用1分钟遍历一个100TB的文件？

要解决这个问题，就要对文件系统的原理有所了解。

文件系统也是一个软件，实际是从简单操作系统文件，到RAID，到分布式文件系统，一以贯之的是文件数据的管理问题，也就是通过文件控制块管理文件的数据。

#### 硬盘

硬盘目前主流的就两种，磁盘和固态；

磁盘的机械臂每次需要移动，这种特质决定了，其对连续存储的文件的读写速度，要明显快于离散存储的文件。

固态硬盘的问题是成本高。

#### 文件系统

作为开发人员，我们一般不直接操作硬盘，而是通过操作系统，以文件的方式对硬盘上的数据进行访问。

> 文件系统将硬盘空间以块为单位进行划分，每个文件占据若干个块，然后再通过一个文件控制块 FCB 记录每个文件占据的硬盘数据块。

在Linux操作系统中，这个文件控制块就是inode，要想访问文件，就要知道文件的inode信息。

inode的基本情况是：

- 记录着文件的基本信息：文件权限，所有者，修改时间和文件大小等
- 文件数据块硬盘地址索引，共15个，包括
  - 前12个是直接地址，因为大部分文件都是小文件，直接的效率最高；
  - 13是一级间接索引表指针，每个索引表可以记录256个索引
  - 14是二级
  - 15是三级
- 所以每个inode最多可以存储12+256+256*256+256*256*256=16843020个数据块
- linux每个文件块是4K，所以单个文件最大是64GB左右

![img](\imgs\30e8aaa432b315e5b16a06a787ff0437.jpg)

所以对题目问题没有办法。

#### RAID

更给力的是磁盘阵列，通过把一个文件写在多个磁盘上，增大容量，提高读写速度。

管理软件是硬件RAID卡或者RAID软件了。

根据硬盘组织和使用方式不同，常用 RAID 有五种，分别是 RAID 0、RAID 1、RAID 10、RAID 5 和 RAID 6。

![img](\imgs\327bcad9c707d4256c98ffeb88f76f0b.jpg)

- 0是把一个文件分别写入多个磁盘。优点是读写速度快，单个文件容量扩大N倍。缺点是可靠性不好，一个磁盘坏就都GG。

- 1是多个磁盘，每个都写一份文件。可靠性高，但浪费磁盘空间。

- 10是结合了0和1的特点。

- 5，6比较特殊。所有RAID方案中，使用最多的是5。

  > RAID 5 针对 RAID 10 硬盘浪费的情况，将数据分成 N-1 片，再利用这 N-1 片数据进行位运算，计算一片校验数据，然后将这 N 片数据写入 N 个硬盘。这样任何一块硬盘损坏，都可以利用校验片的数据和其他数据进行计算得到这片丢失的数据，而硬盘的利用率也提高到 N-1/N。
  >
  > RAID 5 可以解决一块硬盘损坏后文件不可用的问题，那么如果两块文件损坏？RAID 6 的解决方案是，用两种位运算校验算法计算两片校验数据，这样两块硬盘损坏还是可以计算得到丢失的数据片。

但即使这样，还是不能满足一个文件1T，或者比较难。

#### 分布式文件系统

> 如果将数据块的地址改成分布式服务器的地址呢？也就是查询得到的数据块地址不只是本机的硬盘地址，还可以是其他服务器的地址，那么文件的存储容量就将是整个分布式服务器集群的硬盘容量，这样还可以在不同的服务器上同时并行读取文件的数据块，文件访问速度也将极大的加快。
>
> 将数据分成很多片，同时向 N 台服务器上进行数据写入。针对一片数据丢失就导致整个文件损坏的情况，分布式文件系统也是采用数据备份的方式，将多个备份数据片写入多个服务器，以保证文件的可用性。当然，也可以采用 RAID 5 的方式通过计算校验数据片的方式提高文件可用性。
>
> HDFS 的关键组件有两个，一个是 DataNode，一个是 NameNode。
>
> DataNode 负责文件数据的存储和读写操作，HDFS 将文件数据分割成若干数据块（Block），每个 DataNode 存储一部分数据块，这样文件就分布存储在整个 HDFS 服务器集群中。应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得 HDFS 可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。在实践中，HDFS 集群的 DataNode 服务器会有很多台，一般在几百台到几千台这样的规模，每台服务器配有数块硬盘，整个集群的存储容量大概在几 PB 到数百 PB。
>
> NameNode 负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、访问权限、数据块的 ID 以及存储位置等信息，相当于 Linux 系统中 inode 的角色。HDFS 为了保证数据的高可用，会将一个数据块复制为多份（缺省情况为 3 份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。这样当有硬盘损坏，或者某个 DataNode 服务器宕机，甚至某个交换机宕机，导致其存储的数据块不能访问的时候，客户端会查找其备份的数据块进行访问。

有了 HDFS，可以实现单一文件存储几百 T 的数据，再配合大数据计算框架 MapReduce 或者 Spark，可以对这个文件的数据块进行并发计算。也可以使用 Impala 这样的 SQL 引擎对这个文件进行结构化查询，在数千台服务器上并发遍历 100T 的数据，1 分钟都是绰绰有余的。

















## 软件的设计原理

> 在软件的设计原理里，我会讲述如何设计一个强大灵活，易复用，易维护的软件。在这个过程中，应该依赖哪些工具和方法，遵循哪些原则和思想，使用哪些模式和手段。如果软件只是实现功能，那么程序员就没有高下之分，软件也没有好坏之分，技术也就不会有进步。好的软件究竟好在哪里？如何自己也写出一个好的程序？我将在这个模块一一道来。

## 架构的核心原理

> 架构的核心原理围绕目前主要的互联网分布式架构以及大数据物联网架构进行剖析，分析这些架构背后的原理，它们都遵循了怎样的驱动力和设计思想，有哪些看似不同的技术其实原理是一样的，以及如何通过这些技术实现系统的高可用和高性能。

## 技术人的思维修炼

> 软件开发是一个实践性很强的活动，如果你只是学习技术，那么就是在纸上谈兵。只有将知识技能应用到工作实践中，才能真正体会到技术的关键点在哪里，才能分辨出哪些技术是真正有用的，哪些方法是花拳绣腿。但是公司不是你实践技术的实验室，怎样才能处理好工作中的各种关系，得到充分的授权和信任，在工作中实践自己的技术思想，并为公司创造更多价值，得到更多的晋升和发挥的空间，使自己的技术成长和职业发展进入互相促进的正向通道？我将会在第四模块，技术人的思维修炼和你分享一些这方面的方法和认知。

## 参考文献

1 



## TODO List

| 时间 | 内容 |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



## 总结

| 时间 | 内容 |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



