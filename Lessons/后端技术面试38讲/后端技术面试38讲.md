# 38讲

[toc]

尝试掌握基础原理，从原理推导出各种技术实现。

> 太阳底下没有新鲜事，绝大多数新技术其实都脱胎于一些既有的技术体系。
>
> 如果你能建立起这套技术思维体系，掌握这套技术体系背后的原理，那么当你接触一个新技术的时候，就可以快速把握住这个新技术的本质特征和思路方法，然后用你的技术思维体系快速推导出这个新技术是如何实现的。这个时候你其实不需要去学习这个新技术了，而是去验证这个新技术，你会去看它的文档和代码，去验证它是不是和你推导、猜测的实现方式一致，而不是去学习它怎么用了。那么，学习一个新技术就变成了一个简单、轻松、快速且充满乐趣的过程了。你不再惧怕学习新技术，而是开始抱怨：为什么技术革新得这么慢，太无聊了。你甚至可以开始自己创造新技术。
>
> 物理学有一个第一性原理， 指的是根据一些最基本的物理学常量，从头进行物理学的推导，进而得到整个物理学体系。
>
> 第一性原理就是让我们抓住事物最本质的特征原理，依据事物本身的规律，去推导、分析、演绎事物的各种变化规律，进而洞悉事物在各种具体场景下的表现形式，而不是追随事物的表面现象，生搬硬套各种所谓的规矩、经验和技巧，以至于在各种纷繁复杂的冲突和纠结中迷失了方向。
>
> 我们应该从软件技术的第一性原理出发，了解每个基础技术方向那些最关键的技术原理，明白这些原理是如何和我们日常开发工作发生关系的。
>
> 比如我们的程序是如何被操作系统调度执行的？为什么高并发的时候系统会崩溃，原理是什么？在编程时，什么场合下应该使用链表，什么场合下应该使用数组，为什么？当我们使用 Hash 表的时候，什么情况下它的性能会急剧降低，原理又是什么？我们用 Redis 这样的分布式缓存的时候，到底要解决什么问题？分布式缓存是如何工作的？还有哪些技术看起来和 Redis 毫不相干，其实工作原理是一样的？
>
> 如果我们能把这些基本问题都回答清楚了，那么这些问题背后的核心技术原理也都理解了，我们就开始建立起自己的技术思维体系了。当有新的问题和技术出现，你就可以思考，这是属于哪个技术领域的？它的核心原理和哪个技术方案本质是一样的？



## 软件的基础原理

> 软件的基础原理主要是**操作系统、数据结构、数据库原理**等等，我会从一个常见的问题入手，直达这些基础技术最本质的原理，并覆盖这些基础技术的主要关键技术点，让你理解这些基础技术原理和你日常开发工作的关联关系，对这些基础技术有一个全新的认知。

### 01丨程序运行原理：程序是如何运行又是如何崩溃的？

#### 程序是如何运行起来的

- 程序员们编写的代码，经过编译后的可执行代码，都只是静态的，是为程序

- 把程序从磁盘加载到内存中（这个是执行代码的程序，调用系统接口实现的吗？），然后在操作系统的管理调度下交给CPU去执行；此时是进程；

- 进程包含

  - 可执行代码
  - 内存堆空间
  - 栈空间
  - 供操作系统使用的数据结构（？）

  ![img](\imgs\89c6e3bbc44cdc042e7a8bcddb3b4398.png)

- 操作系统把可执行代码加载到内存后，生成相应的数据结构和内存空间后，就从可执行代码的起始位置读取指令，交给CPU顺序执行；
- 堆是一块无序的内存空间，任何时候，进程需要申请内存，都是从堆中分一块出去；
- 分配的内存地址，记录在栈中；栈是严格的后进先出的结构
- 真正执行的函数，永远都在栈顶。栈帧是隔离的，所以不同函数可以定义相同的变量而不会发生混乱。（这个后面要找深入的了解下）

#### 计算机是如何同时处理数百个任务的

- 一句话总结是：CPU的分时共享技术；

- 进程的生命周期：运行、就绪、阻塞；

  > 运行：当一个进程在 CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于 CPU 的数目。
  >
  > 就绪：当一个进程获得了除 CPU 以外的一切所需资源，只要得到 CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。
  >
  > 阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待 I/O 完成，等待锁……）而暂时停止运行，这时即使把 CPU 分配给进程也无法运行，故称该进程处于阻塞状态。

- 进程间的CPU切换，性能开销较大；

- 线程可以理解为轻量级的进程，各种进程的概念都可以套用在线程上；

#### 系统为什么会变慢，为什么会崩溃

- 我们启动的服务，是以一个进程在运行；

- 进程内多线程来提供服务；

- 以 Java 的 web 开发为例，启动多线程，为每个用户请求分配一个处理线程的工作是在 web 容器中完成的，比如常用的 Tomcat 容器。

  ![img](\imgs\d40cc1e9a2a5ce3913670743f0543b9a.png)

- > Tomcat 启动多个线程，为每个用户请求分配一个线程，调用和请求 URL 路径相对应的 Servlet（或者 Controller）代码，完成用户请求处理。而 Tomcat 则在 JVM 虚拟机进程中，JVM 虚拟机则被操作系统当做一个独立进程管理。

- 不管你是否有意识，你开发的 web 程序都是被多线程执行的，web 开发天然就是多线程开发。

- 每个线程有自己的线程栈，所有的线程栈都是完全隔离的，也就是每个方法的参数和方法内的局部变量都是隔离的，一个线程无法访问到其他线程的栈内数据。

- > 多个线程访问共享资源的这段代码被称为临界区，解决线程安全问题的主要方法是使用锁，将临界区的代码加锁，只有获得锁的线程才能执行临界区代码

- 锁会引起线程阻塞，如果有很多线程同时在运行，那么就会出现线程排队等待锁的情况，线程无法并行执行，系统响应速度就会变慢。此外 I/O 操作也会引起阻塞，对数据库连接的获取也可能会引起阻塞。

- 被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，应用崩溃。

### 02丨数据结构原理：Hash表的时间复杂度为什么是O(1)？

要了解 Hash 表，需要先从数组说起。

#### 数组

- 数组是最常用的数据结构，两大要点：

1. 内存地址连续
2. 数据类型相同

- 正因为上述特点，所以可以给定下标，计算出位置，快速读取数据；

- 所以，数组在能力上的特点是：**随机快速读写**；O(1)

- 但如果想给定一个值，找其在数组中的位置啥的，不好意思，O(N)，遍历吧您哪！

#### 链表

- 特点：不连续的内存地址
- 能力：随机插入、删除比较容易；

#### Hash表

- hash：通过一定的规则，把任何值映射为一个数值，这个值就是hash

  > “Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。”

- 旨在解决数组无法很好处理的，通过一个值查到对应值的问题；

- 底层实际是数组，下标通过key的hash值得到；

- 常见的hash算法是取余法；

- 因为数组需要存储相同的数据类型，所以存的是内存地址；

- hash冲突时，相同数据通过链表保存；

- hash表的时间复杂度，在O(1)到O(N)之间摇摆；（极端情况）

#### 栈

- 数组和链表都是线性表，操作无限制；
- 加上操作限制，可以得到特定的数据结构；
- 栈，线性，后进先出；
- 因为是线性，所以可以基于数组或链表实现；

#### 队列

- 队列，线性，先进先出；

#### 树

- 非线性

### 03丨Java虚拟机原理：JVM为什么被称为机器（machine）？

通过JVM屏蔽操作系统的不同，实现了Java程序的一次编写，处处运行。实际上，可以认为JVM干了脏活累活，JVM对应各个操作系统是有不同版本的（比如下载JDK的时候，就是针对不同操作系统的）。

Java程序的一些重点，比如内存管理相关的报错（OOM，StackOverflow等）、线程安全问题等，都和JVM相关。

Java编程的第一性，是否可以考虑从JVM出发。

#### JVM 的组成构造

- JVM主要由三个部分组成：类加载器，运行时数据区，执行引擎；

  ![img](\imgs\62faabeecafe565cbd806022b2aa9c0a.jpg)

  ![img](\imgs\1846149-20200401105306155-3084373.png)

- 类加载器：把class文件加载到JVM中去，在内存中创建对象；不同的ClassLoader加载不同地方的类（jre的，自定义的，拓展的等）

- 运行时数据区（Runtime Data Area）：类似CPU的进程工作原理了。实际上JVM就是一个进程在跑，而程序的运行，是以线程为单位进行的。RDA又分为四个部分：方法区、堆、Java栈、程序计数寄存器（Method Area,Heap Area,Stack Area,PC Registers）；其中的方法区和堆是线程共享的，栈和计数器是线程独占的；

- 一个典型的 Java 程序运行过程是下面这样的

  > 通过 Java 命令启动 JVM，JVM 的类加载器根据 Java 命令的参数到指定的路径加载.class 类文件，类文件被加载到内存后，存放在专门的方法区。然后 JVM 创建一个主线程执行这个类文件的 main 方法，main 方法的输入参数和方法内定义的变量被压入 Java 栈。如果在方法内创建了一个对象实例，这个对象实例信息将会被存放到堆里，而对象实例的引用，也就是对象实例在堆中的地址信息则会被记录在栈里。堆中记录的对象实例信息主要是成员变量信息，因为类方法内的可执行代码存放在方法区，而方法内的局部变量存放在线程的栈里。
  >
  > 程序计数寄存器一开始存放的是 main 方法的第一行代码位置，JVM 的执行引擎根据这个位置去方法区的对应位置加载这行代码指令，将其解释为自身所在平台的 CPU 指令后交给 CPU 执行。如果在 main 方法里调用了其他方法，那么在进入其他方法的时候，会在 Java 栈中为这个方法创建一个新的栈帧，当线程在这个方法内执行的时候，方法内的局部变量都存放在这个栈帧里。当这个方法执行完毕退出的时候，就把这个栈帧从 Java 栈中出栈，这样当前栈帧，也就是堆栈的栈顶就又回到了 main 方法的栈帧，使用这个栈帧里的变量，继续执行 main 方法。这样，即使 main 方法和 f 方法都定义相同的变量，JVM 也不会弄错。这部分内容我们在第一篇已经讨论过，JVM 作为一个 machine，和操作系统的处理线程栈的的方法是一样的。

- 前面提到的JVM运行时数据区的共享和独占，引起了Java中令人头疼的线程安全问题。从栈的角度去理解线程安全的话，有以下几种情况：

  - 所有在方法内定义的基本类型变量，都会被每个运行这个方法的线程放入自己的栈中，线程的栈彼此隔离，所以这些变量一定是线程安全的
  - 如果在方法里创建了一个对象实例，这个对象实例如果没有被方法返回或者放入某些外部的对象容器中的话，也就是说这个对象的引用没有离开这个方法，虽然这个对象被放置在堆中，但是这个对象不会被其他线程访问到，也是线程安全的。
  - 像 Servlet 这样的类，在 Web 容器中创建以后，会被传递给每个访问 Web 应用的用户线程执行，这个类就不是线程安全的。但这并不意味着一定会引发线程安全问题。
  - 如果 Servlet 类里没有成员变量，即使多线程同时执行这个 Servlet 实例的方法，也不会造成成员变量冲突。这种对象被称作无状态对象，也就是说对象不记录状态，执行这个对象的任何方法都不会改变对象的状态，也就不会有线程安全问题了。
  - 虽然我们开发的 Web 应用都是多线程的应用，因为 Web 容器一定会创建多线程来执行我们的代码，但是我们开发中却可以很少考虑线程安全的问题。

- 执行引擎：大名鼎鼎的即时编译器JIT；https://www.cnblogs.com/codehaogg/p/13334713.html

#### JVM的垃圾回收

- JVM在操作系统的基础上更进一步，可以管理内存，也可以对内存标记做垃圾回收；

- 可达性分析：做标记，标记哪些对象被使用中。其实就两步：找到根节点，生成引用图；根节点一般为方法区静态变量、线程帧中的局部变量，从这些root找他们引用的对象，一步步分析。

- 回收算法演进：串行，并行，并发CMS，G1

  ![img](\imgs\492f81e739aba5664ebaf0e08b467134.png)

#### OOM和StackOverflow

- OutOfMemoryError，我们就知道是堆空间不足了，可能是 JVM 分配的内存空间不足以让程序正常运行，这时候我们需要通过调整 -Xmx 参数增加内存空间。也可能是程序存在内存泄漏，比如一些对象被放入 List 或者 Map 等容器对象中，虽然这些对象程序已经不再使用了，但是这些对象依然被容器对象引用，无法进行垃圾回收，导致内存溢出，这时候可以通过 jmap 命令查看堆中的对象情况，分析是否有内存泄漏。
- 如果遇到 StackOverflowError，我们就知道是线程栈空间不足，栈空间不足通常是因为方法调用的层次太多，导致栈帧太多。我们可以先通过栈异常信息观察是否存在错误的递归调用，因为每次递归都会使嵌套方法调用更深入一层。如果调用是正常的，可以尝试调整 -Xss 参数增加栈空间大小。
- 如果程序运行卡顿，部分请求响应延迟比较厉害，那么可以通过 jstat 命令查看垃圾回收器的运行状况，是否存在较长时间的 FullGC，然后调整垃圾回收器的相关参数，使垃圾回收对程序运行的影响尽可能小。













## 软件的设计原理

> 在软件的设计原理里，我会讲述如何设计一个强大灵活，易复用，易维护的软件。在这个过程中，应该依赖哪些工具和方法，遵循哪些原则和思想，使用哪些模式和手段。如果软件只是实现功能，那么程序员就没有高下之分，软件也没有好坏之分，技术也就不会有进步。好的软件究竟好在哪里？如何自己也写出一个好的程序？我将在这个模块一一道来。

## 架构的核心原理

> 架构的核心原理围绕目前主要的互联网分布式架构以及大数据物联网架构进行剖析，分析这些架构背后的原理，它们都遵循了怎样的驱动力和设计思想，有哪些看似不同的技术其实原理是一样的，以及如何通过这些技术实现系统的高可用和高性能。

## 技术人的思维修炼

> 软件开发是一个实践性很强的活动，如果你只是学习技术，那么就是在纸上谈兵。只有将知识技能应用到工作实践中，才能真正体会到技术的关键点在哪里，才能分辨出哪些技术是真正有用的，哪些方法是花拳绣腿。但是公司不是你实践技术的实验室，怎样才能处理好工作中的各种关系，得到充分的授权和信任，在工作中实践自己的技术思想，并为公司创造更多价值，得到更多的晋升和发挥的空间，使自己的技术成长和职业发展进入互相促进的正向通道？我将会在第四模块，技术人的思维修炼和你分享一些这方面的方法和认知。

## 参考文献

1 



## TODO List

| 时间 | 内容 |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



## 总结

| 时间 | 内容 |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



